trigger:
- main

pool:
  name: 'Default'

steps:
# 1) Instala .NET SDK (ajusta a 8.x o 7.x según necesites)
- task: UseDotNet@2
  displayName: 'Install .NET SDK'
  inputs:
    packageType: 'sdk'
    version: '8.x'

# 2) Restore
- task: DotNetCoreCLI@2
  displayName: 'Restore'
  inputs:
    command: 'restore'
    projects: '**/*.csproj'

# 3) Build (Release)
- task: DotNetCoreCLI@2
  displayName: 'Build'
  inputs:
    command: 'build'
    projects: '**/*.csproj'
    arguments: '--configuration Release --no-restore'

# 4) Publish artefacto
- task: DotNetCoreCLI@2
  displayName: 'Publish'
  inputs:
    command: 'publish'
    publishWebProjects: true
    arguments: '--configuration Release --output $(Build.ArtifactStagingDirectory)'
    zipAfterPublish: true

- task: PublishBuildArtifacts@1
  displayName: 'Upload artifact'
  inputs:
    PathtoPublish: '$(Build.ArtifactStagingDirectory)'
    ArtifactName: 'drop'

# ===== DEPLOY A VM POR SSH (simple, sin Kubernetes) =====
- task: CopyFilesOverSSH@0
  displayName: 'Copiar artefacto a VM'
  inputs:
    sshEndpoint: 'SSH_VM'                      # <- nombre exacto de tu Service Connection
    sourceFolder: '$(Build.ArtifactStagingDirectory)'
    contents: '*.zip'
    targetFolder: '/var/www/app'
    overwrite: true

- task: SSH@0
  displayName: 'Descomprimir y arrancar'
  inputs:
    sshEndpoint: 'SSH_VM'                      # <- mismo nombre
    runOptions: 'inline'
    inline: |
      set -e
      sudo apt-get update -y || true
      sudo apt-get install -y unzip psmisc curl || true

      cd /var/www/app
      ZIP_FILE=$(ls -1 *.zip | head -n1)
      rm -rf release && mkdir -p release
      unzip -o "$ZIP_FILE" -d release

      echo "Contenido de release:"
      ls -la release

      # Matar cualquier proceso anterior (DLL o ejecutable)
      pkill -f 'dotnet .*\.dll' || true
      pkill -f 'release/.*' || true
      sleep 1

      ensure_dotnet() {
        if ! command -v dotnet >/dev/null 2>&1; then
          curl -sSL https://dot.net/v1/dotnet-install.sh -o dotnet-install.sh
          chmod +x dotnet-install.sh
          ./dotnet-install.sh --runtime aspnetcore --version latest
          export DOTNET_ROOT=$HOME/.dotnet
          export PATH=$PATH:$HOME/.dotnet:$HOME/.dotnet/tools
        else
          export DOTNET_ROOT=$(dirname $(dirname $(readlink -f $(which dotnet))))
        fi
      }

      # Si hay DLL -> usar dotnet; si no, correr ejecutable publicado
      if ls release/*.dll >/dev/null 2>&1; then
        ensure_dotnet
        DLL=$(ls -1 release/*.dll | head -n1)
        echo "Arrancando DLL: $DLL"
        nohup dotnet "$DLL" --urls "http://0.0.0.0:5000" > app.log 2>&1 &
      else
        APP=$(find release -maxdepth 1 -type f -executable | head -n1 || true)
        if [ -z "$APP" ]; then
          APP=$(ls -1 release/* | head -n1)
          chmod +x "$APP" || true
        fi
        echo "Arrancando ejecutable: $APP"
        nohup "$APP" --urls "http://0.0.0.0:5000" > app.log 2>&1 &
      fi

      # Validación mínima: proceso en ejecución (dotnet o binario)
      sleep 2
      pgrep -a dotnet || pgrep -fa "release/" || (echo "No quedó corriendo"; tail -n 100 app.log; exit 1)
